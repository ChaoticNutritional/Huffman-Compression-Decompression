# Huffman-Compression-Decompression
 
This project was a personal test of programming concepts I've learned so far in hopes to make a complex piece for my graduate school application portfolio. This project was completed in 1.5 weeks outside of a classroom. During this time, I watched lectures and videos on Information Theory and Huffman Coding online, as well as read website documentation on how the algorithm works.

My goal with this project was to learn a new concept and implement it when left to my own devices. As this was an iterative process, I hope that it conveys my train of thought when approaching new topics and concepts.

## TODO:

*NOTE::As this project was intended to be a challenge posed to me by me :) There are a number of things I'd still like to implement that I haven't had the chance to yet, but I'd like to update this as I continue*

- Error checking with exceptions
  - I'd like to implement more error catching using exceptions in a number of cases, but most notably: if the file doesn't exist

- Refactoring
  - I'd like to make sure I can separate this single big cpp file into multiple files, including headers

- Cleanup (General)
  - I left a number of debug statements in as comments, as well as a number of comments either explaining my thought process or explaining a topic that was mostly for me picking up the work again after sleeping so that I could collect my thoughts and jump right back in. Once I get to a solid place, I'll get rid of these and keep them in my personal notes!

- Inversion of bits on Decompression
  - I noticed that during decompression, the tree's position was mirrored which likely had to do with how I've chosen to reconstruct the tree from a compressed file vs. the way it was built to begin with. Since this was made during a self imposed deadline, I felt it was more important to get the project functioning rather than at peak performance _in this case_. In the meantime I have a nested for loop updating the HuffCode values in the pathAsBits map as a stopgap solution. However in the future, moving forward I'd like to see if I can address this at the **root** of the problem.

- General Optimization
  - There are a few key points that I think could perform better than they are currently, and I also feel that there is some potentially unnecessary operations that could be completed elsewhere in the code as well. I'd like to analyze the performance as a whole and debug to see where slowdowns are...

## The program explained

A traditional Huffman compression program is an algorithm used for lossless compression of text data in a file and is a foundation for modern file compression methods.

Huffman compression utilizes a binary tree to store unique characters found in the text to be compressed, and because of the organization of the tree, each character can be assigned a unique binary code in place of its original. This code is generated by tracing the path taken to arrive at a desired leaf node. Traversing to the right results in a '1' and the left in a '0'. The intention of this method is to associate a fewer number of bits to the most frequently occurring characters, and more bits to the least frequent characters.

## The tree

The program works by reading text from a file and creating a binary tree from a collection of nodes held in a min-heap priority queue. Each node contains a unique character from the text along with its associated frequency of occurrence in the file. The priority queue would be stored in such a way that the least frequently occurring characters would be towards the top.

The tree is constructed from the leaf nodes by taking the nodes with the lowest frequency values and creating a parent node pointing to these child nodes with respect to the lowest frequency value set as the left child, and the higher frequency value as the right child. The parent node's frequency is then set to the sum of the frequency of its two children and then the parent is returned to the priority queue.

This process continues until the tree is complete.

## The codebook:

Once the tree is complete, I created a map storing each unique character along with its new bit code. Before outputting anything else to the file, an additional piece of data must be written to the encoded file necessary for decoding the file later. (This was something I struggled with at first.) My solution was to output each node's data value through post order depth first traversal so that each node's children were printed and then a parent node value indicator ('\0'), so that when decompressing, the program could reassemble the tree in sections according to the groundwork created by the post order traversal. (Pushing the parent back onto the stack signifies that the parent itself should be a child along with whatever value appears afterwards)

After this has been done, we can then begin encoding the file itself.

## Encoding the file

I then processed each character from the file or string we intend to encode, and in a new output file writing in binary mode, outputting the corresponding Huffman Code of whatever character we're examining in the file/string into the new file using bitwise arithmetic to 'iterate over bits at a time'. Because the huffman codes may not occupy full bytes, at the end of the translation of character to Huffman codes, we add any necessary padding to round out the byte.

## Decompression

The file is decompressed by reading in the file and reconstructing the tree as outlined in **The codebook** section. After this is done, each bit is read one at a time, and used as an indicator to traverse the tree starting at the root. When this traversal brings us to a leaf, we output that leaf node's character to the DECODED file, and set the traversal pointer back to the root of the tree.
